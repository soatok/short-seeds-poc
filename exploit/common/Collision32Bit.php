<?php
declare(strict_types=1);

class Collision32Bit extends AbstractCollision
{
    private int $maxSteps = 1 << 32;

    /**
     * If we haven't found anything in 2^32 steps, this seed wasn't biased
     *
     * @return int
     */
    protected function getMaxSteps(): int
    {
        return $this->maxSteps;
    }

    public function setMaxSteps(int $max): static
    {
        $this->maxSteps = $max;
        return $this;
    }

    /**
     * Generate a biased keypair.
     *
     * @return array
     * @throws SodiumException
     */
    public function generateKeypair(): array
    {
        // We only set the first 16 bits
        $sk = random_bytes(4) . str_repeat("\x00", 28);
        $pk = sodium_crypto_scalarmult_ristretto255_base(
            sodium_crypto_generichash($sk)
        );
        return [$sk, $pk];
    }

    /**
     * @param array $publicKeys
     * @param int $init
     * @return ?Result
     *
     * @throws SodiumException
     */
    public function linearSearch(array $publicKeys, int $init = 0): ?Result
    {
        $sk = pack('V', $init) . str_repeat("\0", 28);
        for ($steps = 0; $steps < 1 << 32; ++$steps) {
            $pk = sodium_crypto_scalarmult_ristretto255_base(
                sodium_crypto_generichash($sk)
            );
            if (in_array($pk, $publicKeys, true)) {
                return new Result(true, $steps, $sk, $pk);
            }
            sodium_increment($sk);
        }
        return null;
    }

    /**
     * Deliberately introduce bias on this secret key
     *
     * @param string $seed
     * @return string
     * @throws Exception
     */
    public function uniformToBiased(string $seed): string
    {
        if (strlen($seed) !== 32) {
            throw new Exception('Input must be 32 bytes; ' . strlen($seed) . ' given.');
        }
        return $seed[0] . $seed[1] . $seed[2] . $seed[3] . str_repeat("\x00", 28);
    }
}
