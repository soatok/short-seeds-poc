<?php

abstract class AbstractCollision
{
    abstract public function generateKeypair(): array;
    abstract public function uniformToBiased(string $seed): string;
    abstract protected function getMaxSteps(): int;

    /**
     * Generate k distinct keypairs.
     *
     * @param int $requested
     * @return array
     */
    public function createDistinctKeyPairs(int $requested): array
    {
        $keypairs = [];
        $found = [];
        $i = 0;
        while ($i < $requested) {
            // Is this a keypair?
            $candidate = $this->generateKeypair();
            // Prevent duplicates
            if (array_key_exists($candidate[0], $found)) {
                continue;
            }
            $found []= $candidate[0];
            $keypairs[]= $candidate;
            ++$i;
        }
        return $keypairs;
    }

    /**
     * Helper function for grabbing the public keys.
     *
     * @param array $keypairs
     * @return array
     */
    public function extractPublicKeys(array $keypairs): array
    {
        $pk = [];
        foreach ($keypairs as $k) {
            $pk []= $k[1];
        }
        return $pk;
    }

    /**
     * The iteration used by the Pollard's Rho Method.
     *
     * Only the first x bits (16, 32, etc.) of the input public key are preserved. The result is
     * then hashed with BLAKE2b.
     *
     * We then use the result of this hash as the output secret key. We then perform a scalar multiplication
     * over the Ristretto255 group to obtain the public key.
     *
     * We return both pairs.
     *
     * @param string $publicKey
     * @return array
     * @throws SodiumException
     */
    public function iterate(string $publicKey): array
    {
        $sk = $this->uniformToBiased($publicKey);
        $pk = sodium_crypto_scalarmult_ristretto255_base(
            sodium_crypto_generichash($sk)
        );
        return [$sk, $pk];
    }

    public function iterateTwice(string $publicKey): array
    {
        [,$b] = $this->iterate($publicKey);
        return $this->iterate($b);
    }

    /**
     * This just calculates a starting point for each process.
     *
     * We hash all the public keys together, then the parallelism ID.
     *
     * Then, we reduce it to the biased value.
     *
     * @param array $publicKeys
     * @param int $parallelismId
     * @return string
     * @throws SodiumException
     */
    protected function getParallelismStartPoint(array $publicKeys, int $parallelismId = 0): string
    {
        $h = sodium_crypto_generichash_init();
        sodium_crypto_generichash_update($h, pack('P', count($publicKeys)));
        foreach ($publicKeys as $pk) {
            sodium_crypto_generichash_update($h, pack('P', 32));
            sodium_crypto_generichash_update($h, $pk);
        }
        // Add parallelism at the end
        sodium_crypto_generichash_update($h, pack('J', $parallelismId));
        $g = sodium_crypto_generichash_final($h);
        return $this->uniformToBiased($g);
    }

    /**
     * The core of the collision finding algorithm, based on Pollard's Rho method.
     *
     * @param array $publicKeys A list of public keys to attack
     * @param int $parallelismId - Used for running the attack script in GNU Parallel
     * @param bool $allowSelf - Allow self-collisions (for the first two PoCs)
     * @return ?Result
     *
     * @throws SodiumException
     */
    public function findSeedCollisions(array $publicKeys, int $parallelismId = 0, bool $allowSelf = true)
    {
        $sk = $this->getParallelismStartPoint($publicKeys, $parallelismId);
        $pk = sodium_crypto_scalarmult_ristretto255_base(
            sodium_crypto_generichash($sk)
        );

        if (in_array($pk, $publicKeys, true)) {
            // We found it THAT fast? Wow.
            return new Result(true, 0, $sk, $pk);
        }

        // Now let's begin:
        $x = $pk;
        $y = $pk;
        for ($steps = 1; $steps < $this->getMaxSteps(); ++$steps) {
            [$sk1, $pk1] = $this->iterate($x);
            [$sk2, $pk2] = $this->iterateTwice($y);
            // If we want to ignore collisions that don't match one of the candidate keypairs, we disable this.
            // That said, this is a standard implementation of Pollard's Rho method for collision searching.
            if ($allowSelf) {
                if (hash_equals($pk1, $pk2)) {
                    return new Result(true, $steps, $sk2, $pk1);
                }
            }
            if (in_array($pk1, $publicKeys, true)) {
                return new Result(true, $steps, $sk1, $pk1);
            }
            if (in_array($pk2, $publicKeys, true)) {
                return new Result(true, $steps, $sk2, $pk2);
            }
            // Reassign x and y for next iteration
            $x = $pk1;
            $y = $pk2;
        }

        // We did not find anything :(
        return null;
    }
}
